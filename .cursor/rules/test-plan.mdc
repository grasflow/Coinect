# Plan Testów dla Aplikacji Coinect

## 1. Wprowadzenie i Cele Testowania

Plan testów dla aplikacji Coinect, webowej platformy dla freelancerów automatyzującej fakturowanie i analizę czasu pracy, ma na celu zapewnienie wysokiej jakości oprogramowania, zgodności z wymaganiami MVP oraz minimalizacji ryzyka w kluczowych obszarach biznesowych. Cele testowania obejmują weryfikację poprawności funkcjonalności core (autentykacja, zarządzanie czasem, generowanie faktur), bezpieczeństwa danych (RLS w Supabase), dokładności kalkulacji finansowych oraz użyteczności interfejsu użytkownika. Testy skupiają się na hybrydowej architekturze Astro/React z integracjami Supabase i zewnętrznymi API (OpenRouter, NBP, GUS), zapewniając niezawodność w warunkach produkcyjnych.

## 2. Zakres Testów

Zakres obejmuje wszystkie moduły MVP: autentykację i autoryzację, zarządzanie klientami i profilami, wpisy czasu z tagami, generowanie i edycję faktur (wielowalutowe, PDF), insights AI na bazie notatek prywatnych, dashboard z podsumowaniami oraz onboarding. Wykluczone: funkcje post-MVP (integracje z Jira/ClickUp, zaawansowane raporty). Testy obejmują frontend (komponenty React, routing Astro), backend (API endpoints, serwisy), bazę danych (schemat Postgres, RLS) oraz integracje zewnętrzne. Priorytet: core flow – rejestracja → dodanie klienta → wpis czasu → faktura → analiza AI.

## 3. Typy Testów do Przeprowadzenia

- **Testy jednostkowe**: Weryfikacja pojedynczych funkcji i komponentów (np. walidacja Zod schematów, kalkulacje stawek w serwisach TimeEntryService, AuthService). Pokrycie >80% kodu biznesowego.
- **Testy integracyjne**: Integracja modułów (np. API endpoints z Supabase, query TanStack z hookami React), w tym RLS polityki i migracje DB.
- **Testy komponentów w przeglądarce**: Komponenty React w rzeczywistym środowisku przeglądarki z Vitest Browser Mode dla edge cases (Suspense, streaming).
- **Testy end-to-end (E2E)**: Pełne flow użytkownika (np. logowanie → dodanie wpisu czasu → generowanie faktury) z użyciem Playwright.
- **Testy wydajnościowe**: Ładowanie dużych zbiorów danych (np. 1000 wpisów czasu), responsywność AI (czas przetwarzania notatek), load testing z k6.
- **Testy bezpieczeństwa**: Walidacja RLS, ochrona przed SQL injection/XSS, autentykacja JWT, automatyczne skanowanie dependencies (Snyk), static analysis (CodeQL).
- **Testy UI/UX i dostępności**: Responsywność (mobile/desktop), automatyczne testy a11y (axe-playwright), ARIA compliance, kontrast kolorów w Tailwind/Shadcn/ui.
- **Testy visual regression**: Automatyczne wykrywanie zmian wizualnych w UI z Percy/Chromatic.
- **Testy kontraktów API**: Walidacja zgodności frontend/backend endpoints z Pact.io lub OpenAPI schema.
- **Testy regresji**: Po każdej zmianie, automatyzowane dla krytycznych ścieżek.
- **Testy mutacyjne** (opcjonalnie): Weryfikacja jakości testów dla krytycznych serwisów (InvoiceService, TimeEntryService) z Stryker.

## 4. Scenariusze Testowe dla Kluczowych Funkcjonalności

### Autentykacja i Autoryzacja

- SC1: Rejestracja nowego użytkownika z walidacją email/hasło, automatyczne tworzenie profilu.
- SC2: Logowanie z poprawnymi/nieprawidłowymi danymi, obsługa błędów (INVALID_CREDENTIALS).
- SC3: Reset hasła via email, weryfikacja sesji i przekierowanie.
- SC4: Middleware: blokada dostępu do chronionych routów bez sesji, redirect z auth routes po zalogowaniu.

### Zarządzanie Klientami

- SC5: Dodanie/edycja klienta z NIP lookup (GUS API), walidacja unikalności nazwy.
- SC6: Filtrowanie klientów po kraju/walucie, soft delete i RLS (tylko własne dane).

### Wpisy Czasu i Tagi

- SC7: Bulk dodanie wpisów z kalkulacją godzin/stawka, tagowanie i walidacja (hours >0).
- SC8: Filtrowanie po kliencie/dacie/statusie (billed/unbilled), paginacja.
- SC9: Edycja niezafakturowanych wpisów, blokada edycji po fakturowaniu.

### Generowanie Faktur

- SC10: Automatyczne grupowanie wpisów, kalkulacja net/VAT/gross w PLN/EUR/USD z kursem NBP.
- SC11: Edycja faktury (is_edited flag), generowanie PDF, audit trail zmian.
- SC12: Obsługa custom exchange rate, check constraint dla walut obcych.

### Insights AI

- SC13: Analiza prywatnych notatek via OpenRouter (summarize/analyze), obsługa błędów API (429 retry).
- SC14: Agregacja danych do ai_insights_data, próg 20 notatek dla insights.

### Dashboard i Onboarding

- SC15: Wyświetlenie statystyk (clients_count, unbilled_hours), recent entries.
- SC16: Onboarding flow: kroki z progresem, zapis stanu w profilu.

Edge cases: Zero hours, concurrent access, invalid currencies, długie notatki (>10k chars).

## 5. Środowisko Testowe

- **Staging**: Dedykowany projekt Supabase (oddzielny od dev/prod), z mockowanymi API (OpenRouter/GUS/NBP via MSW), Snaplet dla seed data.
- **Lokalne**: Vitest dla unit/integration, Vitest Browser Mode dla component tests, Playwright dla E2E, Supabase local (docker) dla DB testów.
- **CI/CD**: GitHub Actions z Snyk/CodeQL integration, środowiska: dev (branch), staging (PR + visual regression), prod (main).
- **Visual Regression**: Percy/Chromatic baseline z protected branches (main/staging).
- Konfiguracja: TypeScript strict, Tailwind build-time, React 19 z Suspense, axe-core w development.

## 6. Narzędzia do Testowania

### Testy Jednostkowe i Integracyjne

- **Vitest** (v2.0+) z @vitest/ui - natywna integracja z Vite/Astro, ~10x szybszy niż Jest
- **@testing-library/react** + @testing-library/jest-dom - user-centric testing dla React 19
- **Vitest Browser Mode** (eksperymentalny) - component testing w rzeczywistej przeglądarce
- **Zod test utils** - walidacja schematów

### E2E i Testy UI

- **Playwright** (cross-browser: Chrome/Firefox/Safari) - pełne flow użytkownika
- **axe-playwright** - automatyczne testy accessibility w CI
- **@axe-core/react** - runtime monitoring a11y w development
- **Percy/Chromatic** - visual regression testing (snapshoty UI)

### API i Baza Danych

- **@supabase/postgres-testing** (zamiast pg-tap) - nowoczesny framework dla Postgres
- **Snaplet** - seed data snapshots dla konsystentnych testów
- **Supabase test helpers** - RLS validation
- **Pact.io** - contract testing dla API endpoints (frontend ↔ backend)

### Mocki i Fixtures

- **MSW (Mock Service Worker)** v2.0 - mockowanie zewnętrznych API (OpenRouter, GUS, NBP)
- **@supabase/ssr** - auth mock dla testów

### Wydajność

- **k6** (Grafana) - load testing z JavaScript scripting (zamiast Artillery)
- **Lighthouse CI** - performance metrics dla frontend

### Bezpieczeństwo

- **Snyk** - automatyczne skanowanie vulnerabilities w dependencies
- **GitHub Advanced Security** - CodeQL static analysis
- **OWASP ZAP** - penetration testing (scheduled/manual)
- **Manual RLS validation** - testy polityk bezpieczeństwa Supabase

### Raportowanie i Monitoring

- **Vitest UI** (vitest --ui) - interaktywny dashboard dla unit/integration
- **Playwright HTML Reporter** - raporty E2E z screenshots/traces
- **GitHub Actions** - CI/CD integration z coverage reports

### Opcjonalne (Post-MVP)

- **Stryker Mutator** - mutation testing dla krytycznych serwisów

## 7. Harmonogram Testów

### Przygotowanie (Pre-Faza 1)

- Setup Vitest + @vitest/ui, Playwright, MSW
- Konfiguracja Snyk + GitHub Advanced Security w CI
- Setup Percy/Chromatic baseline dla visual regression
- Konfiguracja Snaplet dla staging data

### Faza 1 (Tydzień 1-2)

- Unit testy dla serwisów i komponentów (pokrycie 70%)
- Setup axe-playwright dla automated a11y
- Component tests w Vitest Browser Mode dla krytycznych komponentów (InvoiceForm, TimeEntryBulkAdd)

### Faza 2 (Tydzień 3)

- E2E dla core flow (auth → invoice) z Playwright
- Contract testing (Pact.io) dla kluczowych API endpoints
- Visual regression baseline dla głównych widoków
- Integration tests z Supabase RLS validation

### Faza 3 (Tydzień 4)

- Load testing z k6 (1000+ records, concurrent users)
- Security: OWASP ZAP scan + manual RLS audit
- AI insights testing z real/mock data (OpenRouter)
- Regression suite dla wszystkich krytycznych ścieżek

### Post-MVP (Opcjonalnie)

- Mutation testing (Stryker) dla InvoiceService, TimeEntryService
- Extended contract tests dla wszystkich endpoints

### Cykliczne (CI/CD)

- Po każdym PR: unit/integration, Snyk scan, axe-playwright
- Pre-merge: E2E smoke tests, visual regression
- Weekly: full regression suite, OWASP ZAP scan
- Całkowity czas: 4 tygodnie + 1 tydzień bufor (20%) na bug fixes

## 8. Kryteria Akceptacji Testów

### Pokrycie i Jakość

- Pokrycie kodu: >80% dla business logic, >60% dla UI
- Pass rate: 95% dla automatyzowanych testów, zero krytycznych błędów w E2E
- Mutation score: >75% dla InvoiceService, TimeEntryService (Stryker, post-MVP)

### Bezpieczeństwo

- Brak luk w RLS (100% tabel z prawidłowymi politykami)
- Zero critical/high vulnerabilities w Snyk scan
- Walidacja inputów: 100% coverage dla user inputs
- CodeQL: zero security alerts w production code

### Wydajność

- Ładowanie strony: <2s (Lighthouse score >90)
- API response: <500ms dla 100 rekordów, <2s dla 1000
- k6 load test: <5% error rate przy 100 concurrent users
- Time to Interactive (TTI): <3s na mobile

### Dostępność

- WCAG 2.1 AA compliance: score >90% w axe-core
- Zero critical a11y violations w axe-playwright
- Keyboard navigation: 100% funkcjonalności dostępnych via keyboard

### Visual Regression

- Zero unapproved visual changes w Percy/Chromatic
- Baseline updates tylko dla intentional UI changes

### Kontrakty API

- 100% endpoints pokrytych contract tests (Pact.io)
- Zero breaking changes bez version bump

### Dokumentacja

- Każdy test z opisem (purpose, expected/actual results)
- README z instrukcjami setup dla każdego typu testu
- Coverage reports automatycznie generowane i dostępne w CI

## 9. Role i Odpowiedzialności w Procesie Testowania

- **QA Lead (Inżynier QA)**: Tworzenie planu, scenariuszy, raportowanie; nadzór nad E2E.
- **Developerzy**: Pisanie unit testów dla swoich modułów, fix błędów.
- **DevOps**: Konfiguracja CI/CD, środowisk testowych (Supabase staging).
- **Product Owner**: Walidacja biznesowa, priorytetyzacja testów.
- **Zewnętrzny Reviewer**: Accessibility i security audit.

## 10. Procedury Raportowania Błędów

- **Narzędzie**: GitHub Issues z labelami (bug, test-failure, security, visual-regression, a11y).
- **Szczegóły**: Tytuł (krótki), opis (kroki reprodukcji, expected/actual, screenshots/logs/videos), priorytet (P0-krytyczny: crash/security; P1-wysoki: core flow; P2-średni: UI/visual; P3-niski: edge).
- **Proces**: Zgłoszenie w CI (fail build), automatyczne assignowanie dla security (Snyk/CodeQL), triage w daily meeting, fix w branch, retest + visual approval przed merge.
- **Metryki**: Bug rate <5% po regresji, time-to-resolution <48h dla P0, <5 dni dla P1.
- **Raporty**: Tygodniowe summary w Slack/Notion: pass/fail rates, coverage trends, otwarte issues, security scan results.

## 11. Konfiguracja Techniczna i Setup

### Dependencies (package.json)

```json
{
  "devDependencies": {
    "vitest": "^2.0.0",
    "@vitest/ui": "^2.0.0",
    "@vitest/browser": "^2.0.0",
    "@testing-library/react": "^15.0.0",
    "@testing-library/jest-dom": "^6.4.0",
    "@testing-library/user-event": "^14.5.0",

    "@playwright/test": "^1.45.0",
    "axe-playwright": "^2.0.0",
    "@axe-core/react": "^4.9.0",

    "msw": "^2.3.0",
    "@supabase/postgres-testing": "latest",

    "k6": "^0.50.0",
    "snyk": "^1.1200.0",

    "@pact-foundation/pact": "^13.0.0"
  },
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:browser": "vitest --browser",
    "test:coverage": "vitest --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "test:a11y": "playwright test --grep @a11y",
    "test:visual": "percy exec -- playwright test",
    "test:load": "k6 run tests/load/scenarios.js",
    "test:security": "snyk test && npm audit",
    "test:contracts": "pact-broker can-i-deploy --pacticipant coinect-frontend",
    "test:all": "npm run test && npm run test:e2e && npm run test:a11y"
  }
}
```

### Vitest Config (vitest.config.ts)

```typescript
import { defineConfig } from "vitest/config";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: "jsdom",
    setupFiles: ["./tests/setup.ts"],
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      exclude: ["node_modules/", "dist/", "**/*.spec.ts"],
    },
    browser: {
      enabled: false, // włącz dla component tests
      name: "chromium",
      provider: "playwright",
    },
  },
});
```

### Playwright Config (playwright.config.ts)

```typescript
import { defineConfig, devices } from "@playwright/test";

export default defineConfig({
  testDir: "./tests/e2e",
  fullyParallel: true,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [["html"], ["json", { outputFile: "test-results.json" }]],
  use: {
    baseURL: "http://localhost:4321",
    trace: "on-first-retry",
    screenshot: "only-on-failure",
  },
  projects: [
    { name: "chromium", use: { ...devices["Desktop Chrome"] } },
    { name: "firefox", use: { ...devices["Desktop Firefox"] } },
    { name: "webkit", use: { ...devices["Desktop Safari"] } },
    { name: "mobile", use: { ...devices["iPhone 13"] } },
  ],
  webServer: {
    command: "npm run dev",
    url: "http://localhost:4321",
    reuseExistingServer: !process.env.CI,
  },
});
```

### GitHub Actions CI (.github/workflows/test.yml)

```yaml
name: Tests
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "20"

      - run: npm ci

      # Unit & Integration
      - run: npm run test:coverage

      # Security
      - uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      # CodeQL
      - uses: github/codeql-action/analyze@v3

      # E2E
      - run: npx playwright install --with-deps
      - run: npm run test:e2e

      # Accessibility
      - run: npm run test:a11y

      # Visual Regression (tylko na PR)
      - if: github.event_name == 'pull_request'
        run: npm run test:visual
        env:
          PERCY_TOKEN: ${{ secrets.PERCY_TOKEN }}

      # Upload results
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            coverage/
            playwright-report/
            test-results/
```

### Przykładowe Testy

#### Unit Test (Vitest + Testing Library)

```typescript
// tests/unit/invoice.service.test.ts
import { describe, it, expect } from "vitest";
import { calculateInvoiceTotal } from "@/lib/services/invoice.service";

describe("InvoiceService", () => {
  it("should calculate total with VAT correctly", () => {
    const items = [{ netAmount: 100, vatRate: 23 }];
    const result = calculateInvoiceTotal(items);
    expect(result.gross).toBe(123);
  });
});
```

#### E2E Test (Playwright + axe)

```typescript
// tests/e2e/invoice-flow.spec.ts
import { test, expect } from "@playwright/test";
import AxeBuilder from "axe-playwright";

test("full invoice generation flow @a11y", async ({ page }) => {
  await page.goto("/login");

  // Accessibility check
  const accessibilityScanResults = await new AxeBuilder({ page }).analyze();
  expect(accessibilityScanResults.violations).toEqual([]);

  // Flow test
  await page.fill('[name="email"]', "test@example.com");
  await page.fill('[name="password"]', "password123");
  await page.click('button[type="submit"]');

  await expect(page).toHaveURL("/dashboard");
});
```

#### k6 Load Test

```javascript
// tests/load/scenarios.js
import http from "k6/http";
import { check, sleep } from "k6";

export const options = {
  stages: [
    { duration: "30s", target: 20 },
    { duration: "1m30s", target: 100 },
    { duration: "20s", target: 0 },
  ],
  thresholds: {
    http_req_duration: ["p(95)<500"],
    http_req_failed: ["rate<0.05"],
  },
};

export default function () {
  const res = http.get("http://localhost:4321/api/time-entries");
  check(res, { "status is 200": (r) => r.status === 200 });
  sleep(1);
}
```

## 12. Ostrzeżenia i Znane Ograniczenia

### Vitest Browser Mode

- Status: **eksperymentalny** (stable oczekiwany Q1 2026)
- Fallback: standardowe jsdom environment dla większości component tests
- Use case: tylko dla edge cases wymagających rzeczywistej przeglądarki (Suspense, streaming)

### Snaplet

- Wymaga dodatkowej konfiguracji dla Supabase RLS
- Koszt: free tier ograniczony do 100MB snapshots
- Alternatywa: custom seed scripts jeśli zbyt kosztowne

### Percy/Chromatic

- Koszt: free tier 5,000 snapshots/miesiąc
- Wybór jednego narzędzia (Percy dla standalone, Chromatic jeśli używacie Storybook)

### k6

- Learning curve dla zespołu nieznającego narzędzia
- Setup: wymaga instalacji k6 CLI lokalnie i w CI
- Dokumentacja: https://k6.io/docs/

### Pact.io

- Wymaga Pact Broker (self-hosted lub cloud)
- Koszt: free tier dla open-source, $450/mo dla commercial
- Implementacja stopniowa: start od krytycznych endpoints
